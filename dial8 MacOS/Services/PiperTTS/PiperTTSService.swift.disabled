import Foundation
import AVFoundation
import Combine

/// Service for managing Piper TTS synthesis using Sherpa-ONNX
class PiperTTSService: NSObject, ObservableObject {
    static let shared = PiperTTSService()
    
    // MARK: - Published Properties
    @Published var isPlaying = false
    @Published var isPaused = false
    @Published var currentVoice: SherpaOnnxTTS.PiperVoice = .amyLow {
        didSet {
            UserDefaults.standard.set(currentVoice.rawValue, forKey: "PiperTTSVoice")
            reinitializeTTS()
        }
    }
    @Published var speechRate: Float = 1.0 {
        didSet {
            UserDefaults.standard.set(speechRate, forKey: "PiperTTSSpeechRate")
        }
    }
    
    // MARK: - Private Properties
    private var tts: SherpaOnnxTTS?
    private var audioPlayer: AVAudioPlayer?
    private var completionHandler: (() -> Void)?
    private let audioEngine = AVAudioEngine()
    private let playerNode = AVAudioPlayerNode()
    private var audioFile: AVAudioFile?
    private var pausedFrame: AVAudioFramePosition = 0
    
    // MARK: - Initialization
    override init() {
        super.init()
        
        // Load saved preferences
        if let savedVoice = UserDefaults.standard.string(forKey: "PiperTTSVoice"),
           let voice = SherpaOnnxTTS.PiperVoice(rawValue: savedVoice) {
            self.currentVoice = voice
        }
        
        self.speechRate = UserDefaults.standard.float(forKey: "PiperTTSSpeechRate")
        if speechRate == 0 { speechRate = 1.0 }
        
        // Initialize TTS
        initializeTTS()
        
        // Setup audio engine
        setupAudioEngine()
    }
    
    // MARK: - Private Methods
    private func initializeTTS() {
        do {
            tts = try SherpaOnnxTTS(voice: currentVoice)
            print("ðŸŽ¤ PiperTTS: Initialized with voice: \(currentVoice.displayName)")
        } catch {
            print("ðŸŽ¤ PiperTTS: Failed to initialize: \(error)")
        }
    }
    
    private func reinitializeTTS() {
        tts = nil
        initializeTTS()
    }
    
    private func setupAudioEngine() {
        audioEngine.attach(playerNode)
        let mainMixer = audioEngine.mainMixerNode
        audioEngine.connect(playerNode, to: mainMixer, format: nil)
        
        do {
            try audioEngine.start()
        } catch {
            print("ðŸŽ¤ PiperTTS: Failed to start audio engine: \(error)")
        }
    }
    
    // MARK: - Public Methods
    
    /// Speak the given text using Piper TTS
    func speak(text: String, completion: (() -> Void)? = nil) {
        // Stop any current playback
        stop()
        
        completionHandler = completion
        
        // Generate speech in background
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            
            // Generate audio data
            guard let audioData = self.tts?.generateSpeech(text: text, speed: self.speechRate) else {
                print("ðŸŽ¤ PiperTTS: Failed to generate speech")
                DispatchQueue.main.async {
                    completion?()
                }
                return
            }
            
            // Create temporary file for audio
            let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("piper_tts_\(UUID().uuidString).wav")
            
            // Write WAV file
            if self.writeWAVFile(data: audioData, to: tempURL, sampleRate: 22050) {
                DispatchQueue.main.async {
                    self.playAudioFile(at: tempURL)
                }
            } else {
                print("ðŸŽ¤ PiperTTS: Failed to write audio file")
                DispatchQueue.main.async {
                    completion?()
                }
            }
        }
    }
    
    /// Play audio file
    private func playAudioFile(at url: URL) {
        do {
            audioFile = try AVAudioFile(forReading: url)
            
            guard let audioFile = audioFile,
                  let buffer = AVAudioPCMBuffer(pcmFormat: audioFile.processingFormat,
                                                frameCapacity: AVAudioFrameCount(audioFile.length)) else {
                completionHandler?()
                return
            }
            
            try audioFile.read(into: buffer)
            
            // Schedule buffer
            playerNode.scheduleBuffer(buffer, at: nil, options: []) { [weak self] in
                DispatchQueue.main.async {
                    self?.isPlaying = false
                    self?.completionHandler?()
                    
                    // Clean up temp file
                    try? FileManager.default.removeItem(at: url)
                }
            }
            
            // Start playback
            playerNode.play()
            isPlaying = true
            isPaused = false
            
        } catch {
            print("ðŸŽ¤ PiperTTS: Failed to play audio: \(error)")
            completionHandler?()
        }
    }
    
    /// Pause playback
    func pause() {
        guard isPlaying else { return }
        
        playerNode.pause()
        isPaused = true
        isPlaying = false
    }
    
    /// Resume playback
    func resume() {
        guard isPaused else { return }
        
        playerNode.play()
        isPaused = false
        isPlaying = true
    }
    
    /// Stop playback
    func stop() {
        playerNode.stop()
        isPlaying = false
        isPaused = false
        completionHandler = nil
    }
    
    /// Toggle play/pause
    func togglePlayPause() {
        if isPlaying {
            pause()
        } else if isPaused {
            resume()
        }
    }
    
    /// Write PCM data as WAV file
    private func writeWAVFile(data: Data, to url: URL, sampleRate: Int) -> Bool {
        let pcmFormat = AVAudioFormat(commonFormat: .pcmFormatInt16,
                                      sampleRate: Double(sampleRate),
                                      channels: 1,
                                      interleaved: false)
        
        guard let format = pcmFormat else { return false }
        
        do {
            let audioFile = try AVAudioFile(forWriting: url,
                                           settings: format.settings,
                                           commonFormat: .pcmFormatInt16,
                                           interleaved: false)
            
            // Create buffer from data
            let frameCount = data.count / 2 // 16-bit samples
            guard let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: AVAudioFrameCount(frameCount)) else {
                return false
            }
            
            buffer.frameLength = AVAudioFrameCount(frameCount)
            
            // Copy data to buffer
            data.withUnsafeBytes { bytes in
                let int16Pointer = bytes.bindMemory(to: Int16.self)
                if let channelData = buffer.int16ChannelData {
                    for i in 0..<frameCount {
                        channelData[0][i] = int16Pointer[i]
                    }
                }
            }
            
            try audioFile.write(from: buffer)
            return true
            
        } catch {
            print("ðŸŽ¤ PiperTTS: Failed to write WAV file: \(error)")
            return false
        }
    }
    
    /// Get available voices
    func getAvailableVoices() -> [SherpaOnnxTTS.PiperVoice] {
        return SherpaOnnxTTS.PiperVoice.allCases
    }
    
    /// Generate speech to file
    func generateToFile(text: String, outputPath: String, completion: @escaping (Bool) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else {
                completion(false)
                return
            }
            
            let success = self.tts?.generateSpeechToFile(
                text: text,
                outputPath: outputPath,
                speed: self.speechRate
            ) ?? false
            
            DispatchQueue.main.async {
                completion(success)
            }
        }
    }
}